---
layout: post
title: "类加载机制"
date: 2018-11-18
description: "JVM03--类加载机制"
tag: JVM
---
<h3>1.类加载的过程</h3>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，并最终形成可以被
	虚拟机直接使用的java类型。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;过程：加载-->验证-->准备-->解析-->初始化-->使用-->卸载。其中验证、准备、解析这3个称为连接阶段。
</p>
<h4>1.加载</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;1.通过一个类的全限定名来获取定义此类的二进制字节流。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;2.将这个字节流所代表的静态存储结构转化为方法区运行时的数据结构。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;3.在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。
</p>
<h4>2.验证</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;目的：确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;内容：文件格式验证、元数据验证、字节码验证、符号引用验证。
</p>
<h4>3.准备</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;正式为变量分配内存并设置初始值（系统要求的初始值。比如：在代码里定义变量a int a=10；但a在这个
	阶段设置的初始值为0）
</p>
<h4>4.解析</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;内容：类或接口的解析、字段解析、类方法解析、接口方法解析。
	&nbsp;&nbsp;&nbsp;&nbsp;<br/>
</p>
<h4>5.初始化</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;执行类构造器climit()方法，即：根据程序员通过程序去制定的主观计划去初始化类变量和其它资源。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;注：对类进行初始化的5种情况：<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;1.遇到new、putstatic、getstatic、invokestatic这4条指令的时候。即new一个对象，读取、设置一个
	静态变量、调用一个类的静态方法的时候。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;2.使用java.lang.reflect包的方法对类进行反射调用的时候。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;3.初始化一个类的时候，如果他的父类没有进行初始化则逍遥初始化它的父类。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;4.要执行main方法的时候，包含main方法的那个类要先初始化。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;5.使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.methodHandle的实例最后解析结果是
	REF_putstatic、REF_getstatic、REF_invokestatic的方法句柄，并且这个方法句柄对应的类没有初始化。
</p>
<h3>2.类加载器</h3>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;确定一个类在java虚拟机中的唯一性：类本身+加载它的类加载器。即：比较两个类是否相等时判断他们是否
	来源于同一个class文件和是否被同一个类加载器加载.<br/>
</p>
<h4>1.分类</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;启动类加载器：负责将JAVA_HOME\Lib中或者被-xbootClasspath参数所指定路径中的类库加载到内存中。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;扩展类加载器：负责加载JAVA_HOME\lib\ext目录中的或者被java.ext.dirs系统变量所指定路径的类库。（开发者可直接使用）<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;应用程序类加载器：负责加载用户路径（classpath）上所指定的类库，应用程序默认的类加载器。（开发者可直接使用）
</p>
<h4>2.双亲委派模型</h4>
<p style="margin-left: 2%;">
	<img src="/images/article/jvm/jvm03-allocation.PNG"  alt="双亲委派模型"  align="center"/>
</p>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;描述：除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;工作过程：一个类加载收到类加载请求后，它会优先找他的父类加载器加载（即从启动类加载器往下探索加载，看谁能加载）。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;好处：先加载系统类，再加载用户自定义类。比如先加载java.lang.object类，再加载用户自定义的object类。（越基础的类
	就由越上层的类加载器加载）。
</p>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;双亲委派模型的破坏：<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;1.基础类想要回调用户类的代码：JNDI、JDB等；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;2.用户对程序的动态性追求：代码热替换、模块热部署等。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;3.为了像jdk1.2的java.lang.CassLoader兼容。
</p>



