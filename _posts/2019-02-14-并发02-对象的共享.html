---
layout: post
title: "对象的共享"
date: 2019-02-14
description: "Java并发编程实战--对象的共享"
tag: Java并发编程实战
---
<h3>1.可见性</h3>
<h4>1.可见性的定义</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;当一个线程修改了对象状态后，其它线程能够看到发生的状态变化。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
</p>
<h4>2.失效数据</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;在缺乏同步的过程中可能产生失效数据：当线程A读取线程变量A时，可能有另一个线程已经修改了它，线程A读到的就是过期的数据。
</p>
<h4>3.非原子的64位操作</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;最低安全性：在线程没有同步的情况下读取变量时，可能会得到一个失效值，但这个值至少是由之前某个线程设置的值，而不是一个随机值。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;非volatile类型的64位数值变量（double和long），JVM允许将64位的读操作或者写操作分解为两个32位的操作，因此可能会出现读或者写高32位和低32位的时候不是同一个值。
</p>
<h4>4.加锁与可见性</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。
</p>
<h4>5.volatile变量</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;volatile变量是一种稍弱的同步机制，用于确保变量的更新操作通知到其它线程，而且声明为volatile变量后它就是一个共享的变量，不会缓存到寄存器或者其它处理器不可见的地方。</br>
	&nbsp;&nbsp;&nbsp;&nbsp;从内存的可见性角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。
</p>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;注意：加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;使用volatile变量的条件：<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;1.对变量的写入操作不依赖变量当前的值，或者你能确保只有单个线程更新变量的值；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;2.该变量不会与其它变量一起纳入不变性条件中；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;3.在访问变量时不需要加锁。
</p>

<h3>2.发布与逸出</h3>
<h4>1.发布与逸出的定义</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;发布一个对象：使对象能够在当前作用域之外的代码中使用（即：在其它地方使用这个对象）。被发布的对象要确保对象及内部状态不被发布，如果一定要发布则一定要确保其安全性。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;逸出：某个不应该发布的对象被发布会产生逸出。
</p>
<h4>2.安全对象构造过程</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;不要在构造过程中使this引用逸出，比如在构造函数中启动一个线程，this引用会被会被新创建的线程共享。如果一定要在构造函数中创建线程，最好不要立刻启动，而是通过一个start或initialize方法来启动。
</p>
<h3>3.线程封闭</h3>
<h4>1.线程封闭的定义</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;当访问共享的可变数据时，通常需要使用同步。如果仅在单线程访问数据，就不需要使用同步，这种技术就是线程封闭。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;当某个对象封闭在一个线程时将自动实现线程安全性。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程子系统。
</p>
<h4>2.Ad-hoc线程封闭</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;Ad-hoc线程封闭是指维护线程封闭的职责完全由程序实现来承担。Ad-hoc线程封闭很脆弱，不建议使用，只有在特定情况下才使用。
</p>
<h4>3.栈封闭</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;堆栈封闭其实就是方法中定义局部变量。不存在并发问题。多个线程访问一个方法的时候，方法中的局部变量都会被拷贝一份到线程的栈中（Java内存模型），所以局部变量是不会被多个线程所共享的。
</p>
<h4>4.ThreadLocal类</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;是一种更好的线程封闭的方法。ThreadLocal内部维护了一个map,map的key是每个线程的名称，而map的value就是我们要封闭的对象。ThreadLocal提供了get、set、remove方法，每个操作都是基于当前线程的，所以它是线程安全的。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal对象通常用于防止对可变的变量实例或全局变量进行共享。当某个频繁执行的操作需要一个临时对象，同时又希望避免在每次执行时都需要重新分配该临时对象，就可以使用这项技术。
</p>
<h3>4.不变性</h3>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;未完待续。。。
</p>

